<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Funciones para crear o comprobar vectores de tipo entero</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="Integer_files/libs/clipboard/clipboard.min.js"></script>
<script src="Integer_files/libs/quarto-html/quarto.js"></script>
<script src="Integer_files/libs/quarto-html/popper.min.js"></script>
<script src="Integer_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Integer_files/libs/quarto-html/anchor.min.js"></script>
<link href="Integer_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Integer_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="Integer_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="Integer_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Integer_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Integer_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="Integer_files/libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contenido</h2>
   
  <ul>
  <li><a href="#descripción" id="toc-descripción" class="nav-link active" data-scroll-target="#descripción"><span class="toc-section-number">1</span>  Descripción</a></li>
  <li><a href="#forma-de-uso-o-sintaxis" id="toc-forma-de-uso-o-sintaxis" class="nav-link" data-scroll-target="#forma-de-uso-o-sintaxis"><span class="toc-section-number">2</span>  Forma de uso o sintaxis</a></li>
  <li><a href="#argumentos" id="toc-argumentos" class="nav-link" data-scroll-target="#argumentos"><span class="toc-section-number">3</span>  Argumentos</a></li>
  <li><a href="#detalles" id="toc-detalles" class="nav-link" data-scroll-target="#detalles"><span class="toc-section-number">4</span>  Detalles</a></li>
  <li><a href="#valor-devuelto" id="toc-valor-devuelto" class="nav-link" data-scroll-target="#valor-devuelto"><span class="toc-section-number">5</span>  Valor devuelto</a></li>
  <li><a href="#almacenamiento-entero" id="toc-almacenamiento-entero" class="nav-link" data-scroll-target="#almacenamiento-entero"><span class="toc-section-number">6</span>  Almacenamiento entero</a></li>
  <li><a href="#nota" id="toc-nota" class="nav-link" data-scroll-target="#nota"><span class="toc-section-number">7</span>  Nota</a></li>
  <li><a href="#referencias" id="toc-referencias" class="nav-link" data-scroll-target="#referencias"><span class="toc-section-number">8</span>  Referencias</a></li>
  <li><a href="#también-véase" id="toc-también-véase" class="nav-link" data-scroll-target="#también-véase"><span class="toc-section-number">9</span>  También véase</a></li>
  <li><a href="#ejemplos" id="toc-ejemplos" class="nav-link" data-scroll-target="#ejemplos"><span class="toc-section-number">10</span>  Ejemplos</a></li>
  <li><a href="#código-fuente" id="toc-código-fuente" class="nav-link" data-scroll-target="#código-fuente"><span class="toc-section-number">11</span>  Código fuente</a>
  <ul class="collapse">
  <li><a href="#integer" id="toc-integer" class="nav-link" data-scroll-target="#integer"><span class="toc-section-number">11.1</span>  <code>integer()</code></a></li>
  <li><a href="#as.integer" id="toc-as.integer" class="nav-link" data-scroll-target="#as.integer"><span class="toc-section-number">11.2</span>  <code>as.integer()</code></a></li>
  <li><a href="#is.integer" id="toc-is.integer" class="nav-link" data-scroll-target="#is.integer"><span class="toc-section-number">11.3</span>  <code>is.integer()</code></a></li>
  </ul></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Funciones para crear o comprobar vectores de tipo entero</h1>
<p class="subtitle lead">integer {base}: enteros<br>
Documentación de R, 4.0.0</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="descripción" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="descripción"><span class="header-section-number">1</span> Descripción</h2>
<p>La función <code>integer()</code> creará un vector de <a href="typeof%20%7Bbase%7D" title="typeof {base}">tipo</a> <em>entero</em> (<code>"integer"</code>), que podrá almacenar un subconjunto amplio aunque limitado de números enteros positivos y negativos.</p>
<p>La función <code>as.integer()</code> coaccionará cualquier vector hacia el tipo entero. Por su parte, la función <code>is.integer()</code> verificará si un objeto es de <a href="typeof%20%7Bbase%7D" title="typeof {base}">tipo</a> entero.</p>
</section>
<section id="forma-de-uso-o-sintaxis" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="forma-de-uso-o-sintaxis"><span class="header-section-number">2</span> Forma de uso o sintaxis</h2>
<div class="sourceCode" id="cb1" data-eval="FALSE"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">integer</span>(<span class="at">length =</span> <span class="dv">0</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">as.integer</span>(x, ...)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">is.integer</span>(x)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="argumentos" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="argumentos"><span class="header-section-number">3</span> Argumentos</h2>
<table class="table">
<caption>Argumentos para las funciones de creación y verificación de vectores enteros</caption>
<colgroup>
<col style="width: 20%">
<col style="width: 15%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th>Argumento</th>
<th>Valor esperado</th>
<th>Propósito</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>length=</code></p>
<p><sub><em>longitud</em></sub></p></td>
<td>Un valor entero mayor o igual a cero</td>
<td>Determina la longitud deseada del vector, es decir, el número de elementos que almacenará. El argumento de longitud aceptará números enteros no negativos. Los valores continuos o con decimales (<a href="typeof%20%7Bbase%7D" title="typeof {base}">tipo</a> <a href="double%20%7Bbase%7D" title="double {base}">doble</a>) serán convertidos a enteros y la aportación de más un valor devolverá un mensaje de error.</td>
</tr>
<tr class="even">
<td><code>x=</code></td>
<td>Un objeto</td>
<td>Un objeto para ser coaccionado o verificado como vector de tipo <em>entero</em>.</td>
</tr>
<tr class="odd">
<td><code>...</code></td>
<td>Otros argumentos</td>
<td>Otros argumentos que serán pasados desde o hacia otras funciones.</td>
</tr>
</tbody>
</table>
</section>
<section id="detalles" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="detalles"><span class="header-section-number">4</span> Detalles</h2>
<p>Un vector <em>entero</em> es un tipo de dato de <strong>R</strong> que sirve para almacenar, representar y realizar operaciones con un subconjunto de los números enteros con signo del sistema de numeración decimal, es decir, de los enteros positivos y negativos hasta de cierta magnitud. Este subconjunto es de rango amplio aunque limitado a 32 <em>bits</em>. Para más información sobre el rango de almacenamiento entero, puedes ver más adelante la sección <em>Almacenamiento entero</em>.</p>
<p>El tipo <em>entero</em> permite almacenar de manera exacta valores que representan números sin fracciones decimales y que, en matemáticas, se suelen representar sin marca decimal (ya sea el punto o la coma). Los vectores <em>enteros</em> subsisten como legado de los lenguajes <em>C</em> y <em>Fortran</em>, los cuales forman parte del código interno de <strong>R</strong>. Estos lenguajes requieren, en algunas operaciones especiales, de este tipo de almacenamiento.</p>
<p>Así, <strong>R</strong> define a los vectores <em>enteros</em> como un tipo de almacenamiento exacto que podrá contener cualquier valor de un conjunto de números con signo sin marca decimal en un rango interno de 32 dígitos binarios (<em>bits</em>). Debido a esto, los límites del rango de enteros representables van de <span class="math inline">\(-2^{31}+1\)</span> a <span class="math inline">\(2^{31}-1\)</span> (aproximadamente de <span class="math inline">\(\pm2\times10^9\)</span> ).</p>
<p>Estos límites son resultado de dos definiciones. Por un lado, el exponente tendrá una unidad menor al número de bits porque el signo binario del entero (<span class="math inline">\(0\)</span> para valores positivos o <span class="math inline">\(1\)</span> para negativos) ocupará un dígito de los 32 disponibles. Por otro, al representar valores positivos y negativos, el intervalo de valores posibles atravesará el cero en la recta numérica, por lo que se tendrá que adicionar y sustraer una unidad en los límites del intervalo.</p>
<p>Las funciones básicas para crear vectores <em>enteros</em> son <code>integer()</code>, <code>as.integer()</code> y <a href="c%20%7Bbase%7D" title="c {base}"><code>c()</code></a><em>.</em> Por su parte, la función <code>is.integer()</code> se utilizará para comprobar si un objeto es de <a href="typeof%20%7Bbase%7D" title="typeof {base}">tipo</a> <em>entero</em> (<code>"integer")</code>. En particular, <code>as.integer()</code>, <code>is.integer()</code> y <a href="c%20%7Bbase%7D" title="c {base}"><code>c()</code></a> son funciones <a href="Primitive%20%7Bbase%7D" title="Primitive {base}">primitivas</a>, por lo que su código fuente está implementado de manera interna y no será visible directamente por la usuaria. Para más información sobre la forma de utilización de las funciones mencionadas, puedes consultar la sección <em>Valor devuelto</em> en esta misma página de ayuda.</p>
<p>Como objetos, los vectores <em>enteros</em> son un <a href="vector%20%7Bbase%7D" title="vector {base}">tipo de vector</a> atómico o fundamental de <strong>R</strong>, por lo que no podrán convertirse en objetos más simples ni contener elementos que no sean del mismo tipo. Los <a href="vector%20%7Bbase%7D" title="vector {base}">vectores atómicos</a> están definidos a nivel interno, pero en el entorno del lenguaje es posible observar su modo <a href="typeof%20%7Bbase%7D" title="typeof {base}">específico</a> y <a href="mode%20%7Bbase%7D" title="mode {base}">general</a> de almacenamiento. Los modos de almacenamiento determinan cómo se comportarán los vectores con respecto a otras funciones y objetos, y las operaciones que les son aplicables.</p>
<p>El modo específico de almacenamiento de un vector <em>entero</em> tendrá asignada internamente la etiqueta inglesa <em>entero</em> (<code>"integer")</code> y su modo general de almacenamiento tendrá asociada internamente la etiqueta inglesa <em>numérico</em> (<code>"numeric")</code>. Además, los vectores <em>enteros</em> son una <a href="class%20%7Bbase%7D" title="class {base}">clase de objeto</a> del lenguaje, por lo que también podrán extender sus propiedades a nuevos objetos.</p>
<p>Los vectores de tipo <em>entero</em> (<code>"integer"</code>) podrán almacenar valores enteros en forma más compacta que otros <a href="numeric%20%7Bbase%7D" title="numeric {base}">tipos de almacenamiento numérico</a>, como el almacenamiento <a href="double%20%7Bbase%7D" title="double {base}"><em>doble</em></a> (<code>"double"</code>), que también puede guardar enteros de manera exacta en un rango mucho más amplio. Sin embargo, las capacidades actuales de los ordenadores vuelven imperceptibles, en la práctica, estas ganancias en eficiencia derivadas del uso del tipo de datos <em>entero</em> (<code>"integer"</code>).</p>
<p>Para cada tipo de <a href="vector%20%7Bbase%7D" title="vector {base}">vector</a> atómico, salvo para los vectores <a href="raw%20%7Bbase%7D" title="raw {base}">crudos</a> (<code>"raw"</code>), existe un tipo propio de <a href="NA%20%7Bbase%7D" title="NA {base}">valor no disponible</a> <code>NA</code>. Así, al tipo entero entero le corresponderá el valor no disponible <code>NA_integer_</code>. Sin embargo, los valores no disponibles de los vectores <em>enteros</em> serán mostrados en pantalla solamente con los caracteres <code>NA</code>.</p>
<p>Si deseas asegurarte de que los vectores <em>enteros</em> reciban sólo valores no disponibles de tipo <em>entero</em>, puedes utilizar el valor <code>NA_integer_</code> (en vez de la forma más simple <code>NA</code>) en las operaciones de <a href="assign%20%7Bbase%7D" title="assign {base}">asignación</a>. Para más información puedes ver más adelante la sección <em>Ejemplos</em>, así como la página de ayuda de los <a href="NA%20%7Bbase%7D" title="NA {base}">valores no disponibles</a>.</p>
</section>
<section id="valor-devuelto" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="valor-devuelto"><span class="header-section-number">5</span> Valor devuelto</h2>
<p>Cualquier cifra numérica tecleada sin comillas en la consola (<code>&gt;_</code>) de <strong>R</strong> será devuelta como un número por el lenguaje. Es decir, <strong>R</strong> podrá identificar <em>literales</em> numéricos en el código fuente y los devolverá como valores numéricos constantes. Sin embargo, si lo que deseamos es que el lenguaje devuelva un valor de tipo <em>entero</em>, tenemos que agregar, explícitamente y sin mediar espacios, el sufijo <code>L</code> (por el tipo <code>LONG INTEGER</code> de <em>C</em>) a todos los literales enteros tecleados.</p>
<p>Por ejemplo, para crear directamente el valor <em>entero</em> <code>1</code> debemos usar el sufijo <code>L</code> para calificarlo como un entero. Entonces, el valor <code>1L</code> tecleado en la consola será devuelto como la constante entera <code>1</code>, y tendrá asociada la etiqueta <code>"integer"</code> internamente. En cambio, si sólo tecleamos el literal numérico <code>1</code>, éste será devuelto como un valor de tipo <em>doble</em>.</p>
<p><strong>R</strong> reconoce literales numéricos en el sistema de numeración decimal y hexadecimal. Los valores en base decimal se escribirán literalmente, mientras que los valores en base hexadecimal deberán estar acompañados del prefijo <code>0x</code> o <code>0X</code> para indicar que se tratará de números en esa base. Por ejemplo, la cifra <code>0x10L</code> creará el valor entero <code>16</code> a partir de la representación hexadecimal. Por otro lado, la cifra en notación científica <code>1e3L</code> devolverá el valor entero <code>1000</code> y será equivalente a haber ingresado el literal numérico <code>1000L</code>.</p>
<p>La función <code>integer()</code> creará un vector <em>entero</em> con el número de elementos especificado en el argumento de longitud, <code>length=</code>. Al momento de su creación, cada elemento del vector será igual a cero (<code>0L</code>). Luego, se podrán <a href="assignOps%20%7Bbase%7D" title="assignOps {base}">asignar</a> valores enteros positivos o negativos, así como <a href="NA%20%7Bbase%7D" title="NA {base}">valores no disponibles</a> (<code>NA</code>), al vector recientemente creado.</p>
<p>La función <code>as.integer()</code> intentará coaccionar al objeto referido en el argumento <code>x=</code> al tipo <em>entero</em> y lo devolverá como un vector de este tipo. A menos que la coacción haya sido exitosa, el resultado será un valor no disponible (<code>NA</code>). A diferencia de lo que ocurría en <em>S</em>, que devolvía el número entero más grande posible del mismo signo cuando el valor absoluto de un número real era mayor al límite de enteros representables, en <strong>R</strong>, el valor absoluto de números reales muy grandes será coaccionado al valor no disponible (<code>NA</code>).</p>
<p>Los valores de números reales cuyo valor absoluto sea menor o igual al valor del entero más grande posible serán truncados hacia el cero (es decir, <code>as.integer(x)</code> funcionará igual que <code>trunc(x)</code> en estos casos). Del mismo modo, las partes imaginarias de los valores de <a href="complex%20%7Bbase%7D" title="complex {base}">números complejos</a> se descartarán con una advertencia.</p>
<p><code>as.integer()</code> podrá convertir a valores enteros aquellas cadenas de caracteres (es decir, literales entre comillas) que contengan representaciones de números del sistema decimal o hexadecimal entre espacios en blanco iniciales o finales. No obstante, cada cadena de caracteres deberá contener una sola cifra numérica, sin espacios intercalados, de lo contrario esos elementos serán coaccionados como valores no disponibles (<code>NA</code>). Algunas plataformas de sistema operativo podrían aceptar la coacción de cadenas de caracteres que representen números en otros sistemas de numeración diferentes al decimal o al hexadecimal, como el binario o el octal.</p>
<p><code>as.integer()</code> eliminará los atributos, incluidos los nombres, de los objetos coaccionados, tal como lo hace la función <a href="vector%20%7Bbase%7D" title="vector {base}"><code>as.vector()</code></a>. Para asegurarte de que un objeto <em><code>x</code></em> permanezca con el tipo <em>entero</em> sin perder sus atributos, podrás asignar a un vector la etiqueta del tipo <em>entero</em> (<code>"integer"</code>) con la función <code>storage.mode()</code>, por ejemplo, como en: <code>storage.mode(x) &lt;- "integer"</code>. Esta forma de coacción hacia el tipo <em>entero</em> tiene la ventaja de modificar el <a href="mode%20%7Bbase%7D" title="mode {base}">tipo de almacenamiento</a> sin eliminar los atributos del objeto,</p>
<p>La función <a href="c%20%7Bbase%7D" title="c {base}"><code>c()</code></a> devolverá un vector <em>entero</em> si se utiliza para combinar valores enteros que estén separados por comas, siempre que al final de cada valor numérico se añada, sin mediar espacio, la letra ele mayúscula (<code>L</code>), por ejemplo: <code>c(1L, 2L, 3L)</code>. El resultado de la combinación de elementos enteros creará un vector de tipo <em>entero</em> si ninguno de los valores combinados tiene valores decimales. Para mayor información sobre la combinación de elementos para crear vectores de un determinado tipo puedes ver la página de ayuda de la función <a href="c%20%7Bbase%7D" title="c {base}"><code>c()</code></a>.</p>
<p>La función <code>is.integer()</code> devolverá el <a href="logical%20%7Bbase%7D" title="logical {base}">valor lógico</a> verdadero (<code>TRUE</code>) o falso (<code>FALSE</code>) dependiendo de si el objeto referido en el argumento <code>x=</code> es de tipo <em>entero</em>, es decir, de si el vector tiene asociada internamente la etiqueta <code>"integer"</code>. Toma en cuenta que esta función sólo verificará el <a href="typeof%20%7Bbase%7D" title="typeof {base}">tipo de almacenamiento específico</a> del vector, no si los objetos contenidos en él son, matemáticamente, números enteros; para más información puedes ver las secciones <em>Nota</em> y <em>Ejemplos</em> en esta página de ayuda. En el caso de los <a href="base%20%7Bfactor%7D" title="base {factor}">factores</a>, que asocian números enteros a valores categóricos, <code>is.integer()</code> devolverá el valor lógico falso (<code>FALSE</code>) al momento de verificar el tipo del objeto.</p>
</section>
<section id="almacenamiento-entero" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="almacenamiento-entero"><span class="header-section-number">6</span> Almacenamiento entero</h2>
<p>En términos coloquiales, los enteros son números que se representan sin la marca del separador de decimales, ya sea que la marca decimal utilizada sea el punto ( . ) o la coma ( , ), y pueden ser números tanto positivos como negativos incluyendo al cero. En términos matemáticos, los números enteros se refieren al conjunto <span class="math inline">\(\mathbb{Z}\)</span> que comprende a los subconjuntos de los números naturales <span class="math inline">\(\mathbb{N}\)</span>, al número cero (<span class="math inline">\(0\)</span>) y a los números naturales con signo negativo <span class="math inline">\(-\mathbb{N}\)</span>: <span class="math inline">\(\mathbb{Z}\ni\{...,-3,-2,-1,0,+1,+2,+3,...\}\)</span>.</p>
<p>Algunas de las propiedades más importantes de los números naturales son: 1) entre un número natural <span class="math inline">\(a\)</span> y su sucesor <span class="math inline">\(a+1\)</span> no existe ningún número natural, 2) entre dos números naturales no sucesivos siempre habrá un número finito de números naturales, 3) todo número natural después del número uno (<span class="math inline">\(1\)</span>) es precedido por otro número natural y 4) los números naturales son infinitos. De esta manera, el conjunto de los números enteros <span class="math inline">\(\mathbb{Z}\)</span> hereda las propiedades de los números naturales <span class="math inline">\(\mathbb{N}\)</span> con la adición de los subconjuntos que incluyen al cero (<span class="math inline">\(0\)</span>) y a los naturales negativos <span class="math inline">\(-\mathbb{N}\)</span>.</p>
<p>En computación, un tipo de dato es un conjunto de valores y un conjunto de operaciones definidas para esos valores. Así, un tipo de dato describe a un conjunto de objetos con la misma representación. De esta manera, el tipo de dato entero, llamado también integral, permite representar a un subconjunto de los números enteros (<span class="math inline">\(\mathbb{Z}\)</span>) y realizar operaciones matemáticas con ellos.</p>
<p>El número entero más grande que podrá representarse en una computadora dependerá del tamaño de <em>agrupación del dato</em> del ordenador y del lenguaje de programación. El tamaño de agrupación se refiere al número de <em>bits</em> o dígitos binarios usados para almacenar un número y es variable entre plataformas de sistema (32 o 64 bits, usualmente) y lenguajes de programación. Por este motivo, el subconjunto de enteros disponibles para ser representados también podrá variar en algunas ocasiones.</p>
<p>Entonces, si el tamaño de agrupación para números enteros es de un número de bits o dígitos <span class="math inline">\(n\)</span>, los enteros en base decimal tendrán una representación interna de <span class="math inline">\(n\)</span> dígitos binarios, los cuales podrán adoptar sólo uno de dos valores: cero (<span class="math inline">\(0\)</span>) o uno (<span class="math inline">\(1\)</span>). De esta forma, un número entero tendrá una representación binaria a nivel interno con <span class="math inline">\(n\)</span> dígitos <span class="math inline">\(d\)</span> y <span class="math inline">\(n-1\)</span> posiciones contadas de derecha a izquierda a partir de cero: <span class="math inline">\(d_{n-1}...d_3d_2d_1d_0\)</span>.</p>
<p>En caso de que los enteros puedan adoptar valores positivos y negativos, la posición <span class="math inline">\(n-1\)</span> correspondiente al dígito de extrema izquierda <span class="math inline">\(d_{n-1}\)</span> se destinará a almacenar el valor del signo y será conocida como el <em>bit</em> o banderín de signo. Así, el número cero (<span class="math inline">\(0\)</span>) se usará para identificar a los números mayores o iguales a cero (es decir, los positivos), y el número uno (<span class="math inline">\(1\)</span>) para identificar a los números menores a cero (es decir, los negativos), y corresponderán al valor del signo positivo (<span class="math inline">\(+\)</span>) y negativo (<span class="math inline">\(-\)</span>) de los números en sistema decimal, respectivamente.</p>
<p>Ya que el banderín de signo ocupará un dígito completo en la representación de valores en sistema binario, el número de posiciones disponibles efectivamente para almacenar a un entero será de <span class="math inline">\(n-1\)</span> dígitos binarios. En consecuencia, si se trata de enteros con signo, el rango de representación binaria de estos irá de <span class="math inline">\(-2^{n-1}+1\)</span> a <span class="math inline">\(2^{n-1}-1\)</span>. La adición y sustracción de una unidad en los límites del intervalo es consecuencia del conteo a partir de cero. Si, en cambio, el entero no tiene un digito o banderín de signo, el número de enteros representables será de <span class="math inline">\(2^n\)</span> dígitos e irá, usualmente, de <span class="math inline">\(0\)</span> a <span class="math inline">\(2^n-1\)</span>.</p>
<p>Por ejemplo, cuando el tamaño de agrupación del dato sea de 32 bits entonces se podrán representar hasta <span class="math inline">\(2^{32}\)</span> valores sin signo. Es decir, el tipo entero tendrá <span class="math inline">\(4\,294\,967\,296\)</span> posiciones de almacenamiento. No obstante, si el tamaño de agrupación cuenta con un dígito destinado a representar al signo positivo o negativo, entonces el rango de enteros representables se dividirá en mitades e irá de <span class="math inline">\(-2^{31}+1\)</span> a <span class="math inline">\(+2^{31}-1\)</span>, o sea, de <span class="math inline">\(-2\,147\,483\,647\)</span> a <span class="math inline">\(2\,147\,483\,647\)</span>.</p>
<p>La conversión aritmética de valores en base decimal a base binaria, y viceversa, seguirá un algoritmo estándar en el caso de los enteros positivos y uno especial, conocido en computación como el <em>complemento a dos</em>, en caso de los enteros negativos. A continuación se sintetiza el algoritmo para los cuatro casos posibles.</p>
<ol type="1">
<li><p><strong>Enteros positivos de binario a decimal.</strong> La conversión de un entero binario <span class="math inline">\(x_2\)</span> mayor o igual a cero a su equivalente en base decimal <span class="math inline">\(x_{10}\)</span> se obtendrá al sumar el valor de cada dígito multiplicado por la base binaria (2) elevada a la potencia correspondiente a la posición del digito, así: <span class="math inline">\(x_{10}=d_{n-1}\cdot2^{n-1}+...+d^3\cdot2^3+d_2\cdot2^2+d_1\cdot2^1+d_0\cdot2^0\)</span>.</p></li>
<li><p><strong>Enteros negativos de binario a decimal.</strong> La conversión de un entero binario <span class="math inline">\(x_2\)</span> menor a cero a su equivalente en base decimal <span class="math inline">\(x_{10}\)</span> se podrá realizar con los siguientes pasos. Primero, se deberá realizar la negación (<span class="math inline">\(\neg\)</span>) de los valores del número binario <span class="math inline">\(x_2\)</span>. Luego, a este número se le deberá sumar una unidad en base binaria: <span class="math inline">\(y_2=\neg x_2+1_2\)</span>. Después de realizar la negación y adición de una unidad, al número binario resultante <span class="math inline">\(y_2\)</span> se le podrá convertir a la base decimal con el procedimiento indicado para la conversión de binarios mayores o iguales a cero: <span class="math inline">\(y_{10}=d_{n-1}\cdot2^{n-1}+...+d^3\cdot2^3+d_2\cdot2^2+d_1\cdot2^1+d_0\cdot2^0\)</span>. Finalmente, al número en base decimal <span class="math inline">\(y_{10}\)</span> obtenido, se le deberá multiplicar por menos uno para invertirle el signo: <span class="math inline">\(-y_{10}\)</span>. El resultado de esta multiplicación será el número negativo buscado en base decimal <span class="math inline">\(x_{10}\)</span>. A continuación, se especifica el resumen de este procedimiento: <span class="math inline">\(x_{10} = ( \neg x_2 + 1_2 )_{10} \times -1_{10} = (y_2)_{10} \times -1 = y_{10} \times -1 = -y_{10}\)</span>.</p></li>
<li><p><strong>Enteros positivos de decimal a binario.</strong> De forma inversa, la conversión de un número entero mayor o igual a cero en base decimal <span class="math inline">\(x_{10}\)</span> a su equivalente en base binaria <span class="math inline">\(x_2\)</span> se obtendrá al concatenar cada residuo <span class="math inline">\(r_1...r_n\)</span> obtenido de la sucesiva división del número decimal <span class="math inline">\(x_{10}\)</span> y sus cocientes <span class="math inline">\(q_1...q_{n-1}\)</span> entre la base <span class="math inline">\(b\)</span> (<span class="math inline">\(2\)</span>) hasta que el último cociente <span class="math inline">\(q_n\)</span> sea igual a cero. Una vez que se haya obtenido el número binario positivo <span class="math inline">\(x_2\)</span> se deberá extender la base binaria a su izquierda. Es decir, si el tamaño de agrupación del dato es de <span class="math inline">\(m\)</span> número de <em>bits</em> y el número de dígitos de <span class="math inline">\(x_2\)</span> es <span class="math inline">\(n\)</span>, entonces el número de ceros (<span class="math inline">\(0\)</span>) a concatenar a la izquierda estará dado por <span class="math inline">\(m-n\)</span> siempre que <span class="math inline">\(m≥0\)</span>.</p></li>
<li><p><strong>Enteros negativos de decimal a binario.</strong> Finalmente, la conversión de un número entero negativo en base decimal <span class="math inline">\(x_{10}\)</span> a la base binaria <span class="math inline">\(x_2\)</span> seguirá el mismo procedimiento que el de los enteros positivos pero, adicionalmente, se negará el número obtenido a partir de la concatenación de residuos <span class="math inline">\(y_2=\neg()r_n...r_1\)</span> y luego se sumará una unidad binaria a dicho número: <span class="math inline">\(x_2=y_2+1_2\)</span>. Así, una vez que se haya obtenido el número negativo <span class="math inline">\(x_2\)</span> deberemos extender la base binaria a su izquierda. Es decir, si el tamaño de agrupación del dato es de <span class="math inline">\(m\)</span> número de <em>bits</em> y el número de dígitos de <span class="math inline">\(x_2\)</span> es <span class="math inline">\(n\)</span>, entonces el número de unos (<span class="math inline">\(1\)</span>) a concatenar a la izquierda estará dado por <span class="math inline">\(m-n\)</span> siempre que <span class="math inline">\(m≥n\)</span>.</p></li>
</ol>
<p>A diferencia de la representación de los números reales, cuyo almacenamiento nunca es totalmente exacto, el almacenamiento exacto de los números enteros en base binaria será posible siempre dentro cierto umbral de almacenamiento. Además, debido a que las computadoras almacenan esencialmente la información con el sistema de numeración binaria, el almacenamiento de números en el sistema decimal dejará de ser exacto después de cierto dígito (usualmente el 15), lo cual también aplica para los números enteros. Para más información, véase la página de ayuda sobre el modo de almacenamiento <a href="double%20%7Bbase%7D" title="double {base}">doble</a> y sobre las <a href="Machine%20%7Bbase%7D" title=".Machine {base}">características numéricas de la máquina</a>.</p>
</section>
<section id="nota" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="nota"><span class="header-section-number">7</span> Nota</h2>
<div class="callout-note callout callout-style-simple no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>La expresión <code>is.integer(x)</code> no verificará si un objeto <em><code>x</code></em> contiene valores con números enteros, sino cuál es el <a href="typeof%20%7Bbase%7D" title="typeof {base}">tipo de almacenamiento</a> del vector. Para verificar que los elementos de un vector sean números enteros, en el sentido matemático (<span class="math inline">\(\mathbb{Z}\)</span>), utilice la función <code>round()</code> de la forma indicada en la función <code>es.numeroentero(x)</code> construida en la sección de <em>Ejemplos</em> de esta misma página de ayuda.</p>
</div>
</div>
</div>
</section>
<section id="referencias" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="referencias"><span class="header-section-number">8</span> Referencias</h2>
<p>Becker, Richard A., John M. Chambers, y Allan R. Wilks. The New S Language: A Programming Environment for Data Analysis and Graphics. Wadsworth &amp; Brookscole. Boca Raton, FL: CRC Press, 1988.</p>
</section>
<section id="también-véase" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="también-véase"><span class="header-section-number">9</span> También véase</h2>
<p>Las funciones <code>numeric()</code> y <code>storage.mode()</code> para más información sobre otros tipos de almacenamiento numérico.</p>
</section>
<section id="ejemplos" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="ejemplos"><span class="header-section-number">10</span> Ejemplos</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="do">## as.integer() truncará al coaccionar:</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">&lt;-</span> pi <span class="sc">*</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span><span class="sc">:</span><span class="dv">1</span>, <span class="dv">10</span>) <span class="co"># -3.141593  0.000000  3.141593 31.415927</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">as.integer</span>(x) <span class="co"># -3  0  3 31</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="do">## is.integer() comprobará el tipo de  </span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="do">## almacenamiento, no el valor numérico</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="fu">is.integer</span>(<span class="dv">1</span>) <span class="co"># ¡es falso!</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="fu">is.integer</span>(<span class="cn">NA_integer_</span>) <span class="co"># ¡es verdadero!</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="fu">is.integer</span>(1L) <span class="co"># ¡es verdadero!</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="do">## Función para comprobar que los elementos de un vector entero</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="do">## también son matemáticamente números enteros (Z)</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>es.numeroentero <span class="ot">&lt;-</span> <span class="cf">function</span>(x, <span class="at">tol =</span> .Machine<span class="sc">$</span>double.eps<span class="sc">^</span><span class="fl">0.5</span>) {</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>      <span class="fu">abs</span>(x <span class="sc">-</span> <span class="fu">round</span>(x)) <span class="sc">&lt;</span> tol</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="fu">es.numeroentero</span>(<span class="dv">1</span>) <span class="co"># es verdadero</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="fu">es.numeroentero</span>(<span class="fl">1.0</span>) <span class="co"># es verdadero</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="fu">es.numeroentero</span>(<span class="fl">1.00001</span>) <span class="co"># es falso</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>(x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="at">by =</span> <span class="fl">0.5</span>)) <span class="co"># 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="fu">es.numeroentero</span>(x) <span class="co">#--&gt;  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="do">## Conversión de enteros positivos o negativos</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="do">## del sistema decimal al sistema binario</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>decAbin <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>       concatenar <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                  b <span class="ot">&lt;-</span> <span class="fu">substr</span>(<span class="fu">as.character</span>(<span class="fu">rev</span>(<span class="fu">intToBits</span>(x))), 2L, 2L)</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">paste0</span>(<span class="fu">c</span>(b[1L], <span class="st">" "</span>, b[<span class="dv">2</span><span class="sc">:</span><span class="dv">32</span>]), <span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>      <span class="fu">noquote</span>(<span class="fu">vapply</span>(<span class="fu">as.integer</span>(x),concatenar, <span class="st">""</span>))</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="fu">decAbin</span>(3L) <span class="co">#  0 0000000000000000000000000001111 # Banderín + a la izquierda</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a><span class="fu">decAbin</span>(<span class="sc">-</span>3L) <span class="co"># 1 1111111111111111111111111111101 # Banderín - a la izquierda</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="código-fuente" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="código-fuente"><span class="header-section-number">11</span> Código fuente</h2>
<section id="integer" class="level3" data-number="11.1">
<h3 data-number="11.1" class="anchored" data-anchor-id="integer"><span class="header-section-number">11.1</span> <code>integer()</code></h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>function <span class="op">(</span>length <span class="op">=</span> <span class="dv">0</span><span class="bu">L</span><span class="op">)</span> </span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span>Internal<span class="op">(</span>vector<span class="op">(</span><span class="st">"integer"</span><span class="op">,</span> length<span class="op">))</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="as.integer" class="level3" data-number="11.2">
<h3 data-number="11.2" class="anchored" data-anchor-id="as.integer"><span class="header-section-number">11.2</span> <code>as.integer()</code></h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>function <span class="op">(</span>x<span class="op">)</span> </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>Primitive<span class="op">(</span><span class="st">"as.integer"</span><span class="op">)</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="is.integer" class="level3" data-number="11.3">
<h3 data-number="11.3" class="anchored" data-anchor-id="is.integer"><span class="header-section-number">11.3</span> <code>is.integer()</code></h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>function <span class="op">(</span>x<span class="op">)</span> </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span>Primitive<span class="op">(</span><span class="st">"is.integer"</span><span class="op">)</span></span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<hr>
<p>[Paquete <code>base</code> version 4.2.2 <a href="%7Bbase%7D" title="{base}">Índice</a>]</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>