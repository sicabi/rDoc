<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.269">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Funciones para crear o comprobar vectores de tipo doble</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="double_files/libs/clipboard/clipboard.min.js"></script>
<script src="double_files/libs/quarto-html/quarto.js"></script>
<script src="double_files/libs/quarto-html/popper.min.js"></script>
<script src="double_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="double_files/libs/quarto-html/anchor.min.js"></script>
<link href="double_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="double_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="double_files/libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="double_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="double_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="double_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="double_files/libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contenido</h2>
   
  <ul>
  <li><a href="#descripción" id="toc-descripción" class="nav-link active" data-scroll-target="#descripción"><span class="toc-section-number">1</span>  Descripción</a></li>
  <li><a href="#forma-de-uso-o-sintaxis" id="toc-forma-de-uso-o-sintaxis" class="nav-link" data-scroll-target="#forma-de-uso-o-sintaxis"><span class="toc-section-number">2</span>  Forma de uso o sintaxis</a></li>
  <li><a href="#argumentos" id="toc-argumentos" class="nav-link" data-scroll-target="#argumentos"><span class="toc-section-number">3</span>  Argumentos</a></li>
  <li><a href="#detalles" id="toc-detalles" class="nav-link" data-scroll-target="#detalles"><span class="toc-section-number">4</span>  Detalles</a></li>
  <li><a href="#valor-devuelto" id="toc-valor-devuelto" class="nav-link" data-scroll-target="#valor-devuelto"><span class="toc-section-number">5</span>  Valor devuelto</a></li>
  <li><a href="#sección-adicional" id="toc-sección-adicional" class="nav-link" data-scroll-target="#sección-adicional"><span class="toc-section-number">6</span>  &lt;Sección adicional&gt;</a></li>
  <li><a href="#nota" id="toc-nota" class="nav-link" data-scroll-target="#nota"><span class="toc-section-number">7</span>  Nota</a></li>
  <li><a href="#referencias" id="toc-referencias" class="nav-link" data-scroll-target="#referencias"><span class="toc-section-number">8</span>  Referencias</a></li>
  <li><a href="#también-véase" id="toc-también-véase" class="nav-link" data-scroll-target="#también-véase"><span class="toc-section-number">9</span>  También véase</a></li>
  <li><a href="#ejemplos" id="toc-ejemplos" class="nav-link" data-scroll-target="#ejemplos"><span class="toc-section-number">10</span>  Ejemplos</a></li>
  <li><a href="#código-fuente" id="toc-código-fuente" class="nav-link" data-scroll-target="#código-fuente"><span class="toc-section-number">11</span>  Código fuente</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Funciones para crear o comprobar vectores de tipo doble</h1>
<p class="subtitle lead">integer {base}: enteros<br>
Documentación de R, 4.0.0</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="descripción" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="descripción"><span class="header-section-number">1</span> Descripción</h2>
<p>La función <code>double()</code> creará un vector de tipo <em>doble</em> (<code>"double"</code>), que podrá almacenar un subconjunto muy amplio de los números reales con una precisión muy alta aunque limitada.</p>
<p>La función <code>as.double()</code> intentará convertir en un vector de tipo <em>doble</em> a cualquier tipo de objeto. Por su parte, la función <code>is.double()</code> verificará si un objeto es de tipo <em>doble</em>.</p>
<p>La función <code>single()</code> creará también un vector de tipo <em>doble</em> para almacenamiento de números reales, pero añadirá un atributo que permitirá identificar al vector como uno de tipo <em>simple</em> a nivel interno del código de <code>R</code>. Para más información, puedes ver más adelante la sección <em>Valor devuelto</em>.</p>
<p>La función <code>as.single()</code> intentará coaccionar cualquier objeto hacia un vector de tipo <em>doble</em> y añadirá el atributo mencionado.</p>
</section>
<section id="forma-de-uso-o-sintaxis" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="forma-de-uso-o-sintaxis"><span class="header-section-number">2</span> Forma de uso o sintaxis</h2>
<div class="sourceCode" id="cb1" data-eval="FALSE"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">double</span>(<span class="at">length =</span> <span class="dv">0</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">as.double</span>(x, ...)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">is.double</span>(x)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">single</span>(<span class="at">length =</span> <span class="dv">0</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="fu">as.single</span>(x, ...)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="argumentos" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="argumentos"><span class="header-section-number">3</span> Argumentos</h2>
<table class="table">
<caption>Argumentos para las funciones de creación y verificación de vectores <em>dobles</em></caption>
<colgroup>
<col style="width: 20%">
<col style="width: 15%">
<col style="width: 65%">
</colgroup>
<thead>
<tr class="header">
<th>Argumento</th>
<th>Valor esperado</th>
<th>Propósito</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>length=</code></p>
<p><sub><em>longitud</em></sub></p></td>
<td>Un valor entero mayor o igual a cero</td>
<td>Determina la longitud deseada del vector, es decir, el número de elementos que almacenará. El argumento de longitud aceptará números enteros no negativos. Los valores continuos o con decimales (<a href="typeof%20%7Bbase%7D" title="typeof {base}">tipo</a> <a href="double%20%7Bbase%7D" title="double {base}">doble</a>) serán convertidos a enteros y la aportación de más un valor devolverá un mensaje de error.</td>
</tr>
<tr class="even">
<td><code>x=</code></td>
<td>Un objeto</td>
<td>Un objeto para ser coaccionado o verificado como vector de tipo <em>doble</em>.</td>
</tr>
<tr class="odd">
<td><code>...</code></td>
<td>Otros argumentos</td>
<td>Otros argumentos que serán pasados desde o hacia otras funciones.</td>
</tr>
</tbody>
</table>
</section>
<section id="detalles" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="detalles"><span class="header-section-number">4</span> Detalles</h2>
<p>Un vector <em>doble</em> es una estructura fundamental de <strong>R</strong> destinada al almacenamiento exclusivo de datos de tipo <em>doble</em> en celdas contiguas, así como para realizar operaciones individuales o en paralelo con los elementos de estas celdas. Los datos de tipo <em>doble</em> consisten en un formato de representación de números reales basado en la aritmética de <em>punto flotante</em>.</p>
<p>La aritmética de punto flotante es el formato más extendido entre las computadoras actuales para aproximarse a la aritmética de los números reales y realizar cálculos con ellos. En esencia, permite simular a un conjunto infinito de números continuos (los reales) con los elementos de un conjunto discreto y finito (los números de la máquina). Para más información sobre este formato puedes consutar más adelante la sección <em>La aritmética de punto flontante</em>.</p>
<p>Así, los vectores <em>dobles</em> son el único tipo de vector en <strong>R</strong> que permite almacenar elementos con valores que representan números reales del sistema de numeración decimal hasta cierto nivel de precisión. Originalmente, el primer rango de almacenamiento para números reales fue de 32 <em>bits</em>, por lo que se le denominó de <em>precisión simple</em>. Luego, el siguiente rango de almacenamiento se amplió a 64 <em>bits</em>, por lo que se le denominó de <em>precisión doble</em>.</p>
<p>Específicamente, <strong>R</strong> define a los vectores <em>dobles</em> como un tipo de almacenamiento numérico no exacto en un formato interno de <em>punto flotante</em> que podrá contener cualquier valor de un conjunto de números reales con signo y con marca decimal en un rango de, aproximadamente, <span class="math inline">\(-1.8 \times 10^{308}\)</span> a <span class="math inline">\(1.8 \times 10^{308}\)</span>, o en valor absoluto de, aproximadamente, <span class="math inline">\(|\mp2 \times 10^{-308}|\)</span> a <span class="math inline">\(|\mp1.8 \times 10^{308}|\)</span>.</p>
<p>En este sentido, la precisión doble implica que un número real podrá almacenarse con entre 15 y 17 cifras significativas exactas. A partir del dígito 16, algunos valores podrán ser almacenados de forma aproximada, debido a las características propias del almacenamiento de punto flotante. A partir del dígito 18, las cifras almacenadas tendrán una precisión inexacta. Finalmente, el límite máximo de cifras significativas representables para cualquier número doble es de 22 dígitos.</p>
<p>Si la usuaria desea trabajar con una precisión mayor a 15 cifras significativas se recomienda el uso de paquetes especializados, como {<strong><code>Rmpfr</code></strong>}, el cual permite el almacenamiento de números y la realización de operaciones aritméticas de precisión arbitraria. Sin embargo, los instrumentos físicos más avanzados de la actualidad no suelen medir magnitudes menores a <span class="math inline">\(10^{-15}\)</span> , y muy pocos campos de la física necesitan precisiones mayores, por lo que la mayoría de aplicaciones estadísticas pueden ser cubiertas con la precisión doble.</p>
<p>De este modo, las funciones básicas para crear vectores <em>dobles</em> son <code>double()</code>, <code>as.double()</code> y <a href="c%20%7Bbase%7D" title="c {base}"><code>c()</code></a><em>.</em> Por su parte, la función <code>is.double()</code> se utilizará para comprobar si un objeto es de <a href="typeof%20%7Bbase%7D" title="typeof {base}">tipo</a> <em>doble</em> (<code>"double")</code>. En particular, <code>as.double()</code>, <code>is.double()</code> y <a href="c%20%7Bbase%7D" title="c {base}"><code>c()</code></a> son funciones <a href="Primitive%20%7Bbase%7D" title="Primitive {base}">primitivas</a>, por lo que su código fuente está implementado de manera interna y no será visible directamente por la usuaria. Para más información sobre la forma de utilización de las funciones mencionadas, puedes consultar la sección <em>Valor devuelto</em> en esta misma página de ayuda.</p>
<p>Como objetos, los vectores <em>dobles</em> son un <a href="vector%20%7Bbase%7D" title="vector {base}">tipo de vector</a> atómico o fundamental de <strong>R</strong>, por lo que no podrán convertirse en objetos más simples ni contener elementos que no sean del mismo tipo. Los <a href="vector%20%7Bbase%7D" title="vector {base}">vectores atómicos</a> están definidos a nivel interno por su <a href="typeof%20%7Bbase%7D">tipo de almacenamiento</a>. El tipo de almacenamiento determina el tipo de vector y las operaciones que le son aplicables.</p>
<p>El <a href="typeof%20%7Bbase%7D" title="typeof {base}">tipo interno de almacenamiento</a> de un vector <em>doble</em> tendrá asignada como atributo la etiqueta inglesa <em>doble</em> (<code>"double")</code> y su <a href="mode%20%7Bbase%7D">modo de almacenamiento</a> tendrá asociada como atributo la etiqueta inglesa <em>numérico</em> (<code>"numeric")</code>. Además, los vectores <em>dobles</em> pertenecen a la <a href="class%20%7Bbase%7D" title="class {base}">clase</a><code>"numeric"</code>, por lo que también podrán extender sus propiedades a nuevos objetos.</p>
<p>Los vectores de tipo <em>doble</em> (<code>"double"</code>) podrán almacenar valores enteros en forma exacta más allá del rango de almacenamiento que el tipo <em>entero</em> (<code>"integer"</code>), aproximadamente de <span class="math inline">\(\mp2\times10^9\)</span> .</p>
<p>Para cada tipo de <a href="vector%20%7Bbase%7D" title="vector {base}">vector</a> atómico, salvo para los vectores <a href="raw%20%7Bbase%7D" title="raw {base}">crudos</a> (<code>"raw"</code>), existe un tipo propio de <a href="NA%20%7Bbase%7D" title="NA {base}">valor no disponible</a> <code>NA</code>. Así, al tipo <em>doble</em> entero le corresponderá el valor no disponible <code>NA_real_</code>. Sin embargo, los valores no disponibles de los vectores <em>dobles</em> serán mostrados en pantalla solamente con los caracteres <code>NA</code>.</p>
<p>Si deseas asegurarte de que los vectores <em>dobles</em> reciban sólo valores no disponibles de tipo <em>doble</em>, puedes utilizar el valor <code>NA_real_</code> (en vez de la forma más simple <code>NA</code>) en las operaciones de <a href="assign%20%7Bbase%7D" title="assign {base}">asignación</a>. Para más información puedes consultar más adelante la sección <em>Ejemplos</em>, así como la página de ayuda de los <a href="NA%20%7Bbase%7D" title="NA {base}">valores no disponibles</a>.</p>
</section>
<section id="valor-devuelto" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="valor-devuelto"><span class="header-section-number">5</span> Valor devuelto</h2>
</section>
<section id="sección-adicional" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="sección-adicional"><span class="header-section-number">6</span> &lt;Sección adicional&gt;</h2>
<p>En computación, la <em>precisión</em> de una cifra alude al número de dígitos significativos que pueden ser desplegados en pantalla, independientemente de su exactitud. Por su parte, la <em>exactitud</em> de un formato de almacenamiento se refiere a la correspondencia entre la cifra almacenada internamente y la desplegada en la pantalla del ordenador. Para más información al respecto, puedes ver más adelante la sección <em>El tipo de almacenamiento doble</em>.</p>
</section>
<section id="nota" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="nota"><span class="header-section-number">7</span> Nota</h2>
</section>
<section id="referencias" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="referencias"><span class="header-section-number">8</span> Referencias</h2>
</section>
<section id="también-véase" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="también-véase"><span class="header-section-number">9</span> También véase</h2>
</section>
<section id="ejemplos" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="ejemplos"><span class="header-section-number">10</span> Ejemplos</h2>
</section>
<section id="código-fuente" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="código-fuente"><span class="header-section-number">11</span> Código fuente</h2>
<p>[Paquete <code>{}</code> version 4.2.2 <a href="%7Bbase%7D" title="{base}">Índice</a>]</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>